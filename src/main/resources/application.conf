akka {

  extensions = ["com.romix.akka.serialization.kryo.KryoSerializationExtension$",
  "akka.cluster.metrics.ClusterMetricsExtension",
  "akka.cluster.pubsub.DistributedPubSub"]

  actor {

    provider = "akka.cluster.ClusterActorRefProvider"

    # deployment {
    #   /storekeepers {
    #     dispatcher = control-aware-dispatcher
    #     router = consistent-hashing-pool
    #     cluster {
    #       enabled = on
    #       max-nr-of-instances-per-node = 25
    #       allow-local-routees = on
    #     }
    #   }
    # }

    kryo  {
      type = "graph"
      idstrategy = "automatic"
      buffer-size = 4096
      max-buffer-size = -1
      use-manifests = false
      post-serialization-transformations = "lz4,aes"
      encryption {
        aes {
          mode = "AES/CBC/PKCS5Padding"
          key = j68KkRjq21ykRGAQ
          IV-length = 16
          // custom-key-class = "CustomAESKeyClass"
        }
      }
      implicit-registration-logging = false
      kryo-trace = false
      // kryo-custom-serializer-init = "CustomKryoSerializerInitFQCN"
      // mappings {
      //   "com.actorbase.actorsystem.main.Main" = 20,
      //   "com.actorbase.actorsystem.storefinder.Storefinder" = 21,
      //   "com.actorbase.actorsystem.storekeeper.Storekeeper" = 22,
      //   "com.actorbase.actorsystem.clientactor.ClientActor" = 23,
      //   "com.actorbase.actorsystem.warehouseman.Warehouseman" = 24,
      //   "com.actorbase.actorsystem.utils.ActorbaseCollection" = 25,
      //   "com.actorbase.actorsystem.messages.MainMessages.CreateCollection" = 26,
      //   "com.actorbase.actorsystem.messages.MainMessages.InsertTo" = 27,
      //   "com.actorbase.actorsystem.messages.MainMessages.CompleteTransaction" = 28,
      //   "com.actorbase.actorsystem.messages.StorefinderMessages.PartialMapTransaction" = 29,
      //   "com.actorbase.actorsystem.messages.StorekeeperMessages.GetAll" = 30,
      //   "com.actorbase.actorsystem.messages.StorekeeperMessages.GetItem" = 31,
      //   "com.actorbase.actorsystem.messages.StorekeeperMessages.InsertItem" = 32,
      //   "com.actorbase.actorsystem.messages.StorekeeperMessages.RemoveItem" = 33,
      //   "scala.collection.immutable.Map" = 34,
      //   "scala.collection.mutable.Map" = 35// ,
      //   // "com.actorbase.actorsystem.utils.ActorbaseColletion$.Permissions$" = 36,
      //   // "com.actorbase.actorsystem.utils.ActorbaseCollection$.Read$" = 37,
      //   // "com.actorbase.actorsystem.utils.ActorbaseCollection$.ReadWrite$" = 38
      // }

      // classes = [
      //   "com.actorbase.actorsystem.main.Main",
      //   "com.actorbase.actorsystem.storefinder.Storefinder",
      //   "com.actorbase.actorsystem.storekeeper.Storekeeper",
      //   "com.actorbase.actorsystem.clientactor.ClientActor",
      //   "com.actorbase.actorsystem.warehouseman.Warehouseman",
      //   "com.actorbase.actorsystem.utils.ActorbaseCollection",
      //   "com.actorbase.actorsystem.messages.MainMessages.CreateCollection",
      //   "com.actorbase.actorsystem.messages.MainMessages.InsertTo",
      //   "com.actorbase.actorsystem.messages.MainMessages.CompleteTransaction",
      //   "com.actorbase.actorsystem.messages.StorefinderMessages.PartialMapTransaction",
      //   "com.actorbase.actorsystem.messages.StorekeeperMessages.GetAll",
      //   "com.actorbase.actorsystem.messages.StorekeeperMessages.GetItem",
      //   "com.actorbase.actorsystem.messages.StorekeeperMessages.InsertItem",
      //   "com.actorbase.actorsystem.messages.StorekeeperMessages.RemoveItem",
      //   "scala.collection.immutable.Map",
      //   "scala.collection.mutable.Map",
      //   "com.actorbase.actorsystem.utils.ActorbaseCollection.Read",
      //   "com.actorbase.actorsystem.utils.ActorbaseCollection.ReadWrite"
      // ]
    }

    serializers {
      java = "akka.serialization.JavaSerializer"
      proto = "akka.remote.serialization.ProtobufSerializer"
      akka-cluster = "akka.cluster.protobuf.ClusterMessageSerializer"
      kryo = "com.romix.akka.serialization.kryo.KryoSerializer"
    }

    # serialization-bindings {
    #   "akka.cluster.ClusterMessage" = akka-cluster
    #   "java.lang.String" = java
    #   "com.actorbase.actorsystem.actors.storefinder.Storefinder" = kryo
    #   "com.actorbase.actorsystem.actors.storekeeper.Storekeeper" = kryo
    #   "com.actorbase.actorsystem.messages.MainMessages.CreateCollection" = kryo
    #   "com.actorbase.actorsystem.messages.MainMessages.InsertTo" = kryo
    #   "com.actorbase.actorsystem.messages.MainMessages.CompleteTransaction" = kryo
    #   "com.actorbase.actorsystem.messages.MainMessages.GetFrom" = kryo
    #   "com.actorbase.actorsystem.messages.StorefinderMessages.PartialMapTransaction" = kryo
    #   "com.actorbase.actorsystem.messages.StorefinderMessages.UpdateCollectionSize" = kryo
    #   "com.actorbase.actorsystem.messages.StorekeeperMessages.GetAll" = kryo
    #   "com.actorbase.actorsystem.messages.StorekeeperMessages.GetItem" = kryo
    #   "com.actorbase.actorsystem.messages.StorekeeperMessages.InsertItem" = kryo
    #   "com.actorbase.actorsystem.messages.StorekeeperMessages.RemoveItem" = kryo
    #   "com.actorbase.actorsystem.messages.ClientActorMessages.MapResponse" = kryo
    #   "com.actorbase.actorsystem.messages.AuthActorMessages.Authenticate" = kryo
    #   "com.actorbase.actorsystem.actors.manager.Manager$OneMore$" = kryo
    # }
  }

  loglevel = "INFO"

  cluster {
    auto-down-unreachable-after=off
    seed-nodes = [
      "akka.tcp://"${name}"@"${seed-node}":"${seed-port}
      # "akka.tcp://"${name}"@172.20.10.5:2500",
      # "akka.tcp://"${name}"@172.20.10.3:2501"
      ]

    failure-detector {
      threshold = 12.0
      acceptable-heartbeat-pause = 25s
      heartbeat-interval = 5s
      heartbeat-request {
        expected-response-after = 20s
      }
    }
  }

  remote {
    maximum-payload-bytes = 10000000 bytes
    netty.tcp {
      log-remote-lifecycle-events = off
      hostname = ${listen-on}
      port = ${clustering-port}
      message-frame-size =  10000000b
      send-buffer-size =  10000000b
      receive-buffer-size =  10000000b
      maximum-frame-size = 10000000b
    }

    transport-failure-detector {
      heartbeat-interval = 30 s
      acceptable-heartbeat-pause = 12 s
    }
  }
}

control-aware-dispatcher {

  # mailbox-type = "akka.dispatch.UnboundedDequeBasedMailbox"
  mailbox-type = "akka.dispatch.UnboundedControlAwareMailbox"
  # fork-join-executor {
    #   # Min number of threads to cap factor-based parallelism number to
    #   parallelism-min = 2
    #   # Parallelism (threads) ... ceil(available processors * factor)
    #   parallelism-factor = 2.0
    #   # Max number of threads to cap factor-based parallelism number to
    #   parallelism-max = 10
    # }
  # throughput = 60
}

spray {
  io {
    read-buffer-size="4kspspray.io.tcp.keep-alive=1"
  }
  can {
    server {
      ssl-encryption = off
    }
  }
}

akka.cluster.metrics.enabled=off
akka.persistence.journal.plugin = "akka.persistence.journal.inmem"
akka.persistence.snapshot-store.plugin = "akka.persistence.snapshot-store.local"
# akka.log-dead-letters=on
akka.cluster.roles = [master]
akka.cluster.min-nr-of-members = 4
akka.cluster.role {
  master.min-nr-of-members = 1
  worker.min-nr-of-members = 3
}
name = actorbase

listen-on = "127.0.0.1"

seed-node = "127.0.0.1"

clustering-port = 2500

exposed-port = 9999

max-instances = 10000

storekeepers-per-node = 30

seed-port = 2500